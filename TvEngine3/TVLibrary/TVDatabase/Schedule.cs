#region Copyright (C) 2005-2011 Team MediaPortal

// Copyright (C) 2005-2011 Team MediaPortal
// http://www.team-mediaportal.com
// 
// MediaPortal is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
// 
// MediaPortal is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with MediaPortal. If not, see <http://www.gnu.org/licenses/>.

#endregion

using System;
using System.Collections.Generic;
using Gentle.Framework;
using TvLibrary.Interfaces;
using TvLibrary.Log;

namespace TvDatabase
{
  public enum KeepMethodType
  {
    UntilSpaceNeeded,
    UntilWatched,
    TillDate,
    Always
  }

  public enum ScheduleRecordingType
  {
    Once,
    Daily,
    Weekly,
    EveryTimeOnThisChannel,
    EveryTimeOnEveryChannel,
    Weekends,
    WorkingDays,
    WeeklyEveryTimeOnThisChannel
  }

  /// <summary>
  /// Instances of this class represent the properties and methods of a row in the table <b>Schedule</b>.
  /// </summary>
  [TableName("Schedule")]
  public class Schedule : Persistent
  {
    public static DateTime MinSchedule = new DateTime(2000, 1, 1);
    public static readonly int HighestPriority = Int32.MaxValue;
    //public static readonly int LowestPriority;

    #region Members

    private bool isChanged;
    [TableColumn("id_Schedule", NotNull = true), PrimaryKey(AutoGenerated = true)] private int idSchedule;
    [TableColumn("idChannel", NotNull = true), ForeignKey("Channel", "idChannel")] private int idChannel;

    [TableColumn("idParentSchedule", NotNull = true), ForeignKey("Channel", "idParentSchedule")] private int
      idParentSchedule;

    [TableColumn("scheduleType", NotNull = true)] private int scheduleType;
    [TableColumn("programName", NotNull = true)] private string programName;
    [TableColumn("startTime", NotNull = true)] private DateTime startTime;
    [TableColumn("endTime", NotNull = true)] private DateTime endTime;
    [TableColumn("maxAirings", NotNull = true)] private int maxAirings;
    [TableColumn("priority", NotNull = true)] private int priority;
    [TableColumn("directory", NotNull = true)] private string directory;
    [TableColumn("quality", NotNull = true)] private int quality;
    [TableColumn("keepMethod", NotNull = true)] private int keepMethod;
    [TableColumn("keepDate", NotNull = true)] private DateTime keepDate;
    [TableColumn("preRecordInterval", NotNull = true)] private int preRecordInterval;
    [TableColumn("postRecordInterval", NotNull = true)] private int postRecordInterval;
    [TableColumn("canceled", NotNull = true)] private DateTime canceled;
    [TableColumn("recommendedCard", NotNull = true)] private int recommendedCard;
    [TableColumn("series", NotNull = true)] private bool series;

    #endregion

    #region Constructors

    public Schedule(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      isChanged = true;
      this.idChannel = idChannel;
      this.idParentSchedule = -1;
      ProgramName = programName;
      Canceled = MinSchedule;
      Directory = "";
      EndTime = endTime;
      KeepDate = MinSchedule;
      KeepMethod = (int)KeepMethodType.UntilSpaceNeeded;
      MaxAirings = Int32.MaxValue; //BAV: changed due to mantis bug 1162 - old value 5;
      PostRecordInterval = 0;
      PreRecordInterval = 0;
      Priority = 0;
      quality = 0;
      BitRateMode = VIDEOENCODER_BITRATE_MODE.NotSet;
      QualityType = QualityType.NotSet;
      ScheduleType = (int)ScheduleRecordingType.Once;
      Series = (scheduleType > 0);
      StartTime = startTime;
      recommendedCard = -1;
    }

    /// <summary> 
    /// Create a new object by specifying all fields (except the auto-generated primary key field). 
    /// </summary> 
    public Schedule(int idChannel, int idParentSchedule, int scheduleType, string programName, DateTime startTime,
                    DateTime endTime,
                    int maxAirings, int priority, string directory, int quality, int keepMethod, DateTime keepDate,
                    int preRecordInterval, int postRecordInterval, DateTime canceled)
    {
      isChanged = true;
      this.idChannel = idChannel;
      this.idParentSchedule = idParentSchedule;
      this.scheduleType = scheduleType;
      this.programName = programName;
      this.startTime = startTime;
      this.endTime = endTime;
      this.maxAirings = maxAirings;
      this.priority = priority;
      this.directory = directory;
      this.quality = quality;
      this.keepMethod = keepMethod;
      this.keepDate = keepDate;
      this.preRecordInterval = preRecordInterval;
      this.postRecordInterval = postRecordInterval;
      this.canceled = canceled;
      this.series = (scheduleType > 0);
      recommendedCard = -1;
    }

    /// <summary> 
    /// Create a new schedule from an existing one (except the auto-generated primary key field). 
    /// </summary> 
    public Schedule(Schedule schedule)
    {
      isChanged = true;
      idChannel = schedule.idChannel;
      idParentSchedule = schedule.idParentSchedule;
      scheduleType = schedule.scheduleType;
      programName = schedule.programName;
      startTime = schedule.startTime;
      endTime = schedule.endTime;
      maxAirings = schedule.maxAirings;
      priority = schedule.priority;
      directory = schedule.directory;
      quality = schedule.quality;
      keepMethod = schedule.keepMethod;
      keepDate = schedule.keepDate;
      preRecordInterval = schedule.preRecordInterval;
      postRecordInterval = schedule.postRecordInterval;
      canceled = schedule.canceled;
      series = schedule.Series;
      recommendedCard = -1;
    }

    /// <summary> 
    /// Create an object from an existing row of data. This will be used by Gentle to 
    /// construct objects from retrieved rows. 
    /// </summary> 
    public Schedule(int idSchedule, int idParentSchedule, int idChannel, int scheduleType, string programName,
                    DateTime startTime,
                    DateTime endTime, int maxAirings, int priority, string directory, int quality, int keepMethod,
                    DateTime keepDate, int preRecordInterval, int postRecordInterval, DateTime canceled)
    {
      this.idSchedule = idSchedule;
      this.idParentSchedule = idParentSchedule;
      this.idChannel = idChannel;
      this.scheduleType = scheduleType;
      this.programName = programName;
      this.startTime = startTime;
      this.endTime = endTime;
      this.maxAirings = maxAirings;
      this.priority = priority;
      this.directory = directory;
      this.quality = quality;
      this.keepMethod = keepMethod;
      this.keepDate = keepDate;
      this.preRecordInterval = preRecordInterval;
      this.postRecordInterval = postRecordInterval;
      this.canceled = canceled;
      this.series = (scheduleType > 0);
      recommendedCard = -1;
    }

    #endregion

    #region Public Properties

    /// <summary>
    /// Indicates whether the entity is changed and requires saving or not.
    /// </summary>
    public bool IsChanged
    {
      get { return isChanged; }
    }

    /// <summary>
    /// Property relating to database column id_Schedule
    /// </summary>
    public int IdSchedule
    {
      get { return idSchedule; }
    }

    /// <summary>
    /// Property to get/set the card id recommended by ConflictsManager plugin
    /// </summary>
    public int RecommendedCard
    {
      get { return recommendedCard; }
      set
      {
        isChanged |= recommendedCard != value;
        recommendedCard = value;
      }
    }

    /// <summary>
    /// Property relating to database column idChannel
    /// </summary>
    public int IdChannel
    {
      get { return idChannel; }
      set
      {
        isChanged |= idChannel != value;
        idChannel = value;
      }
    }

    public int IdParentSchedule
    {
      get { return idParentSchedule; }
      set
      {
        isChanged |= idParentSchedule != value;
        idParentSchedule = value;
      }
    }

    /// <summary>
    /// Property relating to database column scheduleType
    /// </summary>
    public int ScheduleType
    {
      get { return scheduleType; }
      set
      {
        isChanged |= scheduleType != value;
        scheduleType = value;
      }
    }

    /// <summary>
    /// Is schedule a manual one
    /// </summary>
    public bool IsManual
    {
      get
      {
        if (scheduleType != (int)ScheduleRecordingType.Once)
        {
          return false;
        }

        TimeSpan ts = (endTime - startTime);
        return (ts.TotalHours == 24);
      }
    }

    /// <summary>
    /// Property relating to database column programName
    /// </summary>
    public string ProgramName
    {
      get { return programName; }
      set
      {
        isChanged |= programName != value;
        programName = value;
      }
    }

    /// <summary>
    /// Property relating to database column startTime
    /// </summary>
    public DateTime StartTime
    {
      get { return startTime; }
      set
      {
        isChanged |= startTime != value;
        startTime = value;
      }
    }

    /// <summary>
    /// Property relating to database column endTime
    /// </summary>
    public DateTime EndTime
    {
      get { return endTime; }
      set
      {
        isChanged |= endTime != value;
        endTime = value;
      }
    }

    /// <summary>
    /// Property relating to database column maxAirings
    /// </summary>
    public int MaxAirings
    {
      get { return maxAirings; }
      set
      {
        isChanged |= maxAirings != value;
        maxAirings = value;
      }
    }

    /// <summary>
    /// Property relating to database column priority
    /// </summary>
    public int Priority
    {
      get { return priority; }
      set
      {
        isChanged |= priority != value;
        priority = value;
      }
    }

    /// <summary>
    /// Property relating to database column directory
    /// </summary>
    public string Directory
    {
      get { return directory; }
      set
      {
        isChanged |= directory != value;
        directory = value;
      }
    }

    /// <summary>
    /// Property relating to database column quality
    /// </summary>
    public int Quality
    {
      get { return quality; }
      set
      {
        isChanged |= quality != value;
        quality = value;
      }
    }

    /// <summary>
    /// Property relating to database column keepMethod
    /// </summary>
    public int KeepMethod
    {
      get { return keepMethod; }
      set
      {
        isChanged |= keepMethod != value;
        keepMethod = value;
      }
    }

    /// <summary>
    /// Property relating to database column keepDate
    /// </summary>
    public DateTime KeepDate
    {
      get { return keepDate; }
      set
      {
        isChanged |= keepDate != value;
        keepDate = value;
      }
    }

    /// <summary>
    /// Property relating to database column preRecordInterval
    /// </summary>
    public int PreRecordInterval
    {
      get { return preRecordInterval; }
      set
      {
        isChanged |= preRecordInterval != value;
        preRecordInterval = value;
      }
    }

    /// <summary>
    /// Property relating to database column postRecordInterval
    /// </summary>
    public int PostRecordInterval
    {
      get { return postRecordInterval; }
      set
      {
        isChanged |= postRecordInterval != value;
        postRecordInterval = value;
      }
    }

    /// <summary>
    /// Property relating to database column canceled
    /// </summary>
    public DateTime Canceled
    {
      get { return canceled; }
      set
      {
        isChanged |= canceled != value;
        canceled = value;
      }
    }

    #endregion

    #region Storage and Retrieval

    /// <summary>
    /// Static method to retrieve all instances that are stored in the database in one call
    /// </summary>
    public static IList<Schedule> ListAll()
    {
      return Broker.RetrieveList<Schedule>();
    }

    public static IList<Schedule> FindOrphanedOnceSchedules()
    {
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      DateTime now = DateTime.Now;
      sb.AddConstraint(Operator.Equals, "scheduleType", 0);
      sb.AddConstraint(Operator.LessThan, "endtime", now);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      IList<Schedule> newList = new List<Schedule>();
      if (getList.Count > 0)
      {
        foreach (Schedule schedule in getList)
        {
          DateTime endPostTime = schedule.endTime.AddMinutes(schedule.postRecordInterval);

          if (endPostTime < now)
          {
            newList.Add(schedule);
          }
        }
      }
      return newList;
    }

    public static Schedule FindNoEPGSchedule(Channel channel)
    {
      int idChannel = channel.IdChannel;

      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.Equals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "idParentSchedule", -1);
      sb.AddConstraint(Operator.Equals, "series", false);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;
    }

    public static bool IsScheduleRecording(int id, Program prg)
    { // this is not about the schedule at all...  is asking whether program is recording right now
      bool isScheduleRecording = false;
      Schedule schedule = Schedule.Retrieve(id);

      prg.Refresh();

      if (schedule != null)
      {
        Schedule spawnedSchedule = Schedule.RetrieveSpawnedSchedule(id, prg.StartTime);
        if (spawnedSchedule != null)
        {
          schedule = spawnedSchedule;
        }

        if (prg != null && prg.IsRecording)
        {
          isScheduleRecording = (Recording.ActiveRecording(schedule.idSchedule) != null);
        }
      }

      return isScheduleRecording;
    }

    public static bool IsScheduleRecording(int id)
    {
      bool isScheduleRecording = false;
      Schedule schedule = Schedule.Retrieve(id);

      if (schedule != null)
      {
        Schedule spawnedSchedule = Schedule.RetrieveSpawnedSchedule(id, schedule.startTime);
        if (spawnedSchedule != null)
        {
          schedule = spawnedSchedule;
        }
        isScheduleRecording = (Recording.ActiveRecording(schedule.idSchedule) != null);
      }

      return isScheduleRecording;
    }

    /// <summary>
    /// Retrieves an entity given it's id.
    /// </summary>
    public static Schedule Retrieve(int id)
    {
      // Return null if id is smaller than seed and/or increment for autokey
      if (id < 1)
      {
        return null;
      }
      Key key = new Key(typeof (Schedule), true, "id_Schedule", id);
      return Broker.TryRetrieveInstance<Schedule>(key);
    }

    /// <summary>
    /// Retrieves an entity given it's id, using Gentle.Framework.Key class.
    /// This allows retrieval based on multi-column keys.
    /// </summary>
    public static Schedule Retrieve(Key key)
    {
      return Broker.TryRetrieveInstance<Schedule>(key);
    }

    public static void SynchProgramStatesForAll()
    {
      Log.Info("schedule.SynchProgramStatesForAll");
      IList<Schedule> allSchedules = Schedule.ListAll();

      if (allSchedules != null && allSchedules.Count > 0)
      {
        foreach (Schedule schedule in allSchedules)
        {
          Schedule.SynchProgramStates(schedule.idSchedule);
        }
      }
    }

    public static void ResetProgramStates(int idSchedule)
    {
      Schedule schedule = Schedule.Retrieve(idSchedule);
      if (schedule == null)
      {
        return;
      }

      var progs = GetProgramsForSchedule(schedule);
      foreach (var prog in progs)
      {
        Program.ResetPendingState(prog.IdProgram);
        prog.Persist();
      }
    }

    public static void SynchProgramStates(int idSchedule)
    {
      Schedule schedule = Schedule.Retrieve(idSchedule);
      if (schedule == null)
      {
        return;
      }

      var progs = GetProgramsForSchedule(schedule);
      foreach (var prog in progs)
      {
        if(schedule.IsSerieIsCanceled(schedule.GetSchedStartTimeForProg(prog)))
        {
          // program has been cancelled so reset any pending recording flags
          Program.ResetPendingState(prog.IdProgram);
          prog.Persist();
        }
        else
        {
          bool isPartialRecording = Schedule.IsPartialRecording(schedule, prog);
          if (schedule.ScheduleType == (int)ScheduleRecordingType.Once)
          {
            // is one off recording that is still active so set pending flags accordingly
            prog.IsRecordingOncePending = true;
            prog.IsRecordingSeriesPending = false;
            prog.IsPartialRecordingSeriesPending = false;
            prog.Persist();
          }
          else if (isPartialRecording)
          {
            // is part of a series recording but is a time based schedule and program times do not
            // match up with schedule times so flag as partial recording
            prog.IsRecordingOncePending = false;
            prog.IsRecordingSeriesPending = false;
            prog.IsPartialRecordingSeriesPending = true;
            prog.Persist();
          }
          else
          {
            // is part of a series recording but is not a partial recording
            prog.IsRecordingOncePending = false;
            prog.IsRecordingSeriesPending = true;
            prog.IsPartialRecordingSeriesPending = false;
            prog.Persist();
          }
        }
      }
    }

    public static IList<Program> GetProgramsForSchedule(Schedule schedule)
    {
      IList<Program> progs = null;
      switch (schedule.scheduleType)
      {
        case (int)ScheduleRecordingType.Once:
          var prgOnce = Program.RetrieveOnce(schedule.programName, schedule.startTime, schedule.endTime,
                                                 schedule.ReferencedChannel().IdChannel);
          progs = new List<Program>();
          if (prgOnce != null)
          {
            progs.Add(prgOnce);
          }
          break;

        case (int)ScheduleRecordingType.Daily:
          progs = Program.RetrieveDaily(schedule.startTime, schedule.endTime,schedule.ReferencedChannel().IdChannel);
          break;

        case (int)ScheduleRecordingType.EveryTimeOnEveryChannel:
          progs = Program.RetrieveEveryTimeOnEveryChannel(schedule.programName);
          break;

        case (int)ScheduleRecordingType.EveryTimeOnThisChannel:
          progs = Program.RetrieveEveryTimeOnThisChannel(schedule.programName, schedule.ReferencedChannel().IdChannel);
          break;

        case (int)ScheduleRecordingType.WeeklyEveryTimeOnThisChannel:
          progs = Program.RetrieveWeeklyEveryTimeOnThisChannel(schedule.startTime, schedule.endTime, schedule.programName, schedule.ReferencedChannel().IdChannel);
          break;

        case (int)ScheduleRecordingType.Weekends:
          progs = Program.RetrieveWeekends(schedule.startTime, schedule.endTime, schedule.ReferencedChannel().IdChannel);
          break;

        case (int)ScheduleRecordingType.Weekly:
          progs = Program.RetrieveWeekly(schedule.startTime, schedule.endTime, schedule.ReferencedChannel().IdChannel);
          break;

        case (int)ScheduleRecordingType.WorkingDays:
          progs = Program.RetrieveWorkingDays(schedule.startTime, schedule.endTime, schedule.ReferencedChannel().IdChannel);
          break;
      }

      return progs;
    }

    public static bool IsPartialRecording(Schedule schedule, Program prg)
    {
      if (schedule.ScheduleType == (int)ScheduleRecordingType.EveryTimeOnEveryChannel ||
          schedule.ScheduleType == (int)ScheduleRecordingType.EveryTimeOnThisChannel ||
          schedule.ScheduleType == (int)ScheduleRecordingType.WeeklyEveryTimeOnThisChannel)
      {
        return false;
      }

      DateTime schStart;
      DateTime schEnd;

      if (schedule.GetAdjustedScheduleTimeRange(prg, out schStart, out schEnd))
      {
        return (prg.StartTime < schStart || prg.EndTime > schEnd);
      }
      else
      {
        Log.Info(
          "IsPartialRecording: program ({0} {1} - {2} is not (at least partially) included in the schedule {3:hh:mm} - {4:hh:mm}",
          prg.Title, prg.StartTime, prg.EndTime, schedule.startTime, schedule.endTime);
        return false;
      }
    }


    /// <summary>
    /// Persists the entity if it was never persisted or was changed.
    /// </summary>
    public override void Persist()
    {
      if (IsChanged || !IsPersisted)
      {
        try
        {
          base.Persist();

          //WE HAVE TO HANDLE CANCELLED SCHEDULES AND SKIP THOSE - WE DO NOT WANT TO MARK CANCLLED AS recpending.

          SynchProgramStates(this.idSchedule);
        }
        catch (Exception ex)
        {
          Log.Error("Exception in Schedule.Persist() with Message {0}", ex.Message);
          return;
        }
        isChanged = false;
      }
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>    
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, string programName)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Series' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>    
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveSeries(int idChannel, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.NotEquals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    /// <summary>
    /// Retreives the first found instance of a 'Once' typed schedule given its Channel,Title,Start and End Times 
    /// </summary>
    /// <param name="idChannel">Channel id to look for</param>
    /// <param name="programName">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <returns>schedule instance or null</returns>
    public static Schedule RetrieveOnce(int idChannel, string programName, DateTime startTime, DateTime endTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // 
      sb.AddConstraint(Operator.Equals, "scheduleType", 0);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      sb.AddConstraint(Operator.Equals, "programName", programName);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);
      sb.AddConstraint(Operator.Equals, "endTime", endTime);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      return null;

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(ChannelMap), this );
    }

    #endregion

    #region Relations

    /// <summary>
    /// Get a list of CanceledSchedule referring to the current entity.
    /// </summary>
    public IList<CanceledSchedule> ReferringCanceledSchedule()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (CanceledSchedule));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idSchedule", idSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<CanceledSchedule>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }

    /// <summary>
    /// Get a list of Conflicts referring to the current entity.
    /// </summary>
    public IList<Conflict> ReferringConflicts()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Conflict));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idSchedule", idSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Conflict>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }

    /// <summary>
    /// Get a list of Conflicts referring to the current entity.
    /// </summary>
    public IList<Conflict> ConflictingSchedules()
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Conflict));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "idConflictingSchedule", idSchedule);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Conflict>(stmt.Execute());

      // TODO In the end, a GentleList should be returned instead of an arraylist
      //return new GentleList( typeof(CanceledSchedule), this );
    }


    /// <summary>
    ///
    /// </summary>
    public Channel ReferencedChannel()
    {
      return Channel.Retrieve(IdChannel);
    }

    /// <summary>
    ///
    /// </summary>
    public Schedule ReferencedSchedule()
    {
      return Schedule.Retrieve(idParentSchedule);
    }

    #endregion

    public bool IsSerieIsCanceled(DateTime startTimeParam)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam)
        {
          return true;
        }
      }
      return false;
    }

    public bool IsSerieIsCanceled(DateTime startTimeParam, int idChannel)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam && schedule.IdChannel == idChannel)
        {
          return true;
        }
      }
      return false;
    }

    public void UnCancelSerie()
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        schedule.Remove();
        Program.SetSingleStateSeriesPending(schedule.CancelDateTime,
                                            schedule.IdChannel,
                                            schedule.ReferencedSchedule().ProgramName);
      }
      return;
    }

    public void UnCancelSerie(DateTime startTimeParam, int idChannel)
    {
      foreach (CanceledSchedule schedule in ReferringCanceledSchedule())
      {
        if (schedule.CancelDateTime == startTimeParam && schedule.IdChannel == idChannel)
        {
          schedule.Remove();
          Program.SetSingleStateSeriesPending(schedule.CancelDateTime,
                                              schedule.IdChannel,
                                              schedule.ReferencedSchedule().ProgramName);
        }
      }
      return;
    }

    /// <summary>
    /// Checks if the recording should record the specified tvprogram
    /// </summary>
    /// <param name="program">TVProgram to check</param>
    /// <returns>true if the specified tvprogram should be recorded</returns>
    /// <returns>filterCanceledRecordings (true/false)
    /// if true then  we'll return false if recording has been canceled for this program</returns>
    /// if false then we'll return true if recording has been not for this program</returns>
    public bool IsRecordingProgram(Program program, bool filterCanceledRecordings)
    {
      if (program == null)
      {
        return false;
      }
      ScheduleRecordingType scheduleRecordingType = (ScheduleRecordingType)ScheduleType;
      switch (scheduleRecordingType)
      {
        case ScheduleRecordingType.Once:
          {
            if (program.StartTime == StartTime && program.EndTime == EndTime && program.IdChannel == IdChannel)
            {
              if (filterCanceledRecordings)
              {
                if (ReferringCanceledSchedule().Count > 0)
                {
                  return false;
                }
              }
              return true;
            }
          }
          break;
        case ScheduleRecordingType.EveryTimeOnEveryChannel:
          if (program.Title == ProgramName)
          {
            if (filterCanceledRecordings && IsSerieIsCanceled(GetSchedStartTimeForProg(program), program.IdChannel))
            {
              return false;
            }
            return true;
          }
          break;
        case ScheduleRecordingType.EveryTimeOnThisChannel:
          if (program.Title == ProgramName && program.IdChannel == IdChannel)
          {
            if (filterCanceledRecordings && IsSerieIsCanceled(GetSchedStartTimeForProg(program), program.IdChannel))
            {
              return false;
            }
            return true;
          }
          break;
        case ScheduleRecordingType.WeeklyEveryTimeOnThisChannel:
          if (program.Title == ProgramName && program.IdChannel == IdChannel &&
              StartTime.DayOfWeek == program.StartTime.DayOfWeek)
          {
            if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
            {
              return false;
            }
            return true;
          }
          break;
        case ScheduleRecordingType.Daily:
          if (program.IdChannel == IdChannel)
          {
            return IsRecordingProgramWithinTimeRange(program, filterCanceledRecordings);

            /*int iHourProg = program.StartTime.Hour;
            int iMinProg = program.StartTime.Minute;
            if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
            {
              iHourProg = program.EndTime.Hour;
              iMinProg = program.EndTime.Minute;
              if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
              {
                if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                {
                  return false;
                }
                return true;
              }
            }*/
          }
          break;
        case ScheduleRecordingType.WorkingDays:
          if (WeekEndTool.IsWorkingDay(program.StartTime.DayOfWeek))
          {
            if (program.IdChannel == IdChannel)
            {
              return IsRecordingProgramWithinTimeRange(program, filterCanceledRecordings);
              /*
              int iHourProg = program.StartTime.Hour;
              int iMinProg = program.StartTime.Minute;
              if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
              {
                iHourProg = program.EndTime.Hour;
                iMinProg = program.EndTime.Minute;
                if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
                {
                  if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                  {
                    return false;
                  }
                  return true;
                }
              }*/
            }
          }
          break;

        case ScheduleRecordingType.Weekends:
          if (WeekEndTool.IsWeekend(program.StartTime.DayOfWeek))
          {
            if (program.IdChannel == IdChannel)
            {
              return IsRecordingProgramWithinTimeRange(program, filterCanceledRecordings);

              /*
              int iHourProg = program.StartTime.Hour;
              int iMinProg = program.StartTime.Minute;
              if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
              {
                iHourProg = program.EndTime.Hour;
                iMinProg = program.EndTime.Minute;
                if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
                {
                  if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                  {
                    return false;
                  }
                  return true;
                }
              }*/
            }
          }
          break;

        case ScheduleRecordingType.Weekly:
          if (program.IdChannel == IdChannel)
          {
            return (StartTime.DayOfWeek == program.StartTime.DayOfWeek &&
                    IsRecordingProgramWithinTimeRange(program, filterCanceledRecordings));
            /*
            int iHourProg = program.StartTime.Hour;
            int iMinProg = program.StartTime.Minute;
            if (iHourProg == StartTime.Hour && iMinProg == StartTime.Minute)
            {
              iHourProg = program.EndTime.Hour;
              iMinProg = program.EndTime.Minute;
              if (iHourProg == EndTime.Hour && iMinProg == EndTime.Minute)
              {
                if ((StartTime.DayOfWeek == program.StartTime.DayOfWeek) && (program.StartTime.Date >= StartTime.Date))
                {
                  if (filterCanceledRecordings && IsSerieIsCanceled(program.StartTime))
                  {
                    return false;
                  }
                  return true;
                }
              }
            }*/
          }
          break;
      }
      return false;
    }

    private bool IsRecordingProgramWithinTimeRange(Program program, bool filterCanceledRecordings)
    {
      DateTime scheduleStartTime;
      DateTime scheduleEndTime;

      bool isProgramWithinStartEndTimes = GetAdjustedScheduleTimeRange(program, out scheduleStartTime,
                                                                       out scheduleEndTime);
      bool isSerieNotCanceled = false;

      if (isProgramWithinStartEndTimes)
      {
        isSerieNotCanceled = !(filterCanceledRecordings && IsSerieIsCanceled(scheduleStartTime));
      }
      return isSerieNotCanceled;
    }

    /// <summary>
    /// This takes a program as an argument and overlaps it with the schedule start time
    /// The date element of the start time of a schedule is the date of the first episode
    /// but for cancelling episodes of a time based schedule the cancellation row in the database 
    /// needs the start time of the episode rather than a program.
    /// eg. if a schedule is setup 20:00 until 21:00 every day starting on 1st April and on 3rd April the 
    /// there is no program for this period and user selects a program at 20:30 to 21:30 and asks to 
    /// cancel the epsiode, we need to return 3rd April 20:00 
    /// 
    /// If program does not fall within schedule (eg. you call with a program that starts 21:30)
    /// this will return that start time of the program
    /// </summary>
    /// <param name="prog">The program to check</param>
    /// <returns>The start time of the episode within a schedule that overlaps with program</returns>
    public DateTime GetSchedStartTimeForProg(Program prog)
    {
      DateTime dtSchedStart;
      DateTime dtSchedEnd;
      if (GetAdjustedScheduleTimeRange(prog, out dtSchedStart, out dtSchedEnd))
      {
        return dtSchedStart;
      }
      return prog.StartTime;
    }

    /// <summary>
    /// Try to offset this schedule's time range by an integral number
    /// of days so that it overlaps the <paramref name="program"/> time range.
    /// </summary>
    /// <param name="program">The program to use for adjusting the timerange</param>
    /// <param name="scheduleStart">The adjusted start date/time</param>
    /// <param name="scheduleEnd">The adjusted end date/time</param>
    /// <returns>True if a suitable adjustment was found</returns>
    private bool GetAdjustedScheduleTimeRange(Program program, out DateTime scheduleStart, out DateTime scheduleEnd)
    {
      scheduleStart = new DateTime(program.StartTime.Year, program.StartTime.Month, program.StartTime.Day,
                                   startTime.Hour, startTime.Minute, 0).AddDays(-1);
      scheduleEnd = scheduleStart.Add(endTime.Subtract(startTime));

      // Try to find on which day schedule should start in order to overlap the program
      // First try <program start day>-1
      // e.g. schedule 23:00-01:00, program 00:30-01:30
      if (program.StartTime >= scheduleEnd || program.EndTime <= scheduleStart)
      {
        // Then try <program start day>
        // e.g. schedule 18:00-20:00, program 17:30-19:30 (this is the most usual case)
        scheduleEnd = scheduleEnd.AddDays(1);
        scheduleStart = scheduleStart.AddDays(1);
        if (program.StartTime >= scheduleEnd || program.EndTime <= scheduleStart)
        {
          // Finally try <program start day>+1
          // e.g. schedule 00:30-01:30, program 23:00-01:00
          scheduleEnd = scheduleEnd.AddDays(1);
          scheduleStart = scheduleStart.AddDays(1);
          if (program.StartTime >= scheduleEnd || program.EndTime <= scheduleStart)
          {
            return false; // no overlap found
          }
        }
      }
      return true;
    }

    public bool DoesUseEpisodeManagement
    {
      get
      {
        if (MaxAirings == Int32.MaxValue)
        {
          return false;
        }
        if (MaxAirings < 1)
        {
          return false;
        }
        return true;
      }
    }

    /// <summary>
    /// Checks whether this recording is finished and can be deleted
    /// 
    /// </summary>
    /// <returns>true:Recording is finished can be deleted
    ///          false:Recording is not done yet, or needs to be done multiple times
    /// </returns>
    public bool IsDone()
    {
      if (ScheduleType != (int)ScheduleRecordingType.Once)
      {
        return false;
      }
      if (DateTime.Now > EndTime)
      {
        return true;
      }
      return false;
    }

    public void Delete()
    {
      int id = this.idSchedule;
      IList<Conflict> list = ReferringConflicts();
      foreach (Conflict conflict in list)
      {
        conflict.Remove();
      }

      list = ConflictingSchedules();
      foreach (Conflict conflict in list)
      {
        conflict.Remove();
      }

      IList<CanceledSchedule> listCanceledSchedule = ReferringCanceledSchedule();
      foreach (CanceledSchedule schedule in listCanceledSchedule)
      {
        schedule.Remove();
      }

      // does the schedule still exist ?
      // if yes then remove it, if no leave it.
      Schedule schedExists = Retrieve(idSchedule);
      if (schedExists != null)
      {
        Schedule.ResetProgramStates(id);
        Remove();
      }
    }

    public bool Series
    {
      get { return series; }
      set { series = value; }
    }

    public Schedule Clone()
    {
      Schedule schedule = new Schedule(IdChannel, idParentSchedule, scheduleType, ProgramName, StartTime, EndTime,
                                       MaxAirings, Priority,
                                       Directory, Quality, KeepMethod, KeepDate, PreRecordInterval, PostRecordInterval,
                                       Canceled);

      schedule.series = series;
      schedule.idSchedule = idSchedule;
      schedule.isChanged = false;
      return schedule;
    }

    public bool IsOverlapping(Schedule schedule)
    {
      DateTime Start1 = StartTime.AddMinutes(-preRecordInterval);
      DateTime Start2 = schedule.StartTime.AddMinutes(-schedule.preRecordInterval);
      DateTime End1 = EndTime.AddMinutes(postRecordInterval);
      DateTime End2 = schedule.EndTime.AddMinutes(schedule.postRecordInterval);

      // sch_1        s------------------------e
      // sch_2    ---------s-----------------------------
      // sch_2    s--------------------------------e
      // sch_2  ------------------e
      if ((Start2 >= Start1 && Start2 < End1) ||
          (Start2 <= Start1 && End2 >= End1) ||
          (End2 > Start1 && End2 <= End1))
      {
        return true;
      }
      return false;
    }

    /// <summary>
    /// checks if 2 schedules have a common Transponder
    /// depending on tuningdetails of their respective channels
    /// </summary>
    /// <param name="schedule"></param>
    /// <returns>True if a common transponder exists</returns>
    public bool isSameTransponder(Schedule schedule)
    {
      IList<TuningDetail> tuningList1 = ReferencedChannel().ReferringTuningDetail();
      IList<TuningDetail> tuningList2 = schedule.ReferencedChannel().ReferringTuningDetail();
      foreach (TuningDetail tun1 in tuningList1)
      {
        foreach (TuningDetail tun2 in tuningList2)
        {
          if (tun1.Frequency == tun2.Frequency)
          {
            return true;
          }
        }
      }
      return false;
    }

    public QualityType QualityType
    {
      get { return (QualityType)(quality / 10); }
      set
      {
        int type = ((int)value);
        quality = (type * 10) + (quality % 10);
      }
    }

    public VIDEOENCODER_BITRATE_MODE BitRateMode
    {
      get { return (VIDEOENCODER_BITRATE_MODE)(quality % 10); }
      set
      {
        int mode = ((int)value);
        quality = mode + ((quality / 10) * 10);
      }
    }

    public override string ToString()
    {
      return String.Format("{0} on {1} {2} - {3}  ID={4}", ProgramName, IdChannel, StartTime, EndTime, idSchedule);
    }

    /// <summary>
    /// Retreives the programs with a given title and starting between given Start and End Times 
    /// </summary>
    /// <param name="title">Title we wanna look for</param>
    /// <param name="startTime">StartTime</param>
    /// <param name="endTime">EndTime</param>
    /// <param name="idChannel">The id of the channel</param>
    /// <returns></returns>
    public static IList<Schedule> RetrieveByTitleAndTimesInterval(string title, DateTime startTime, DateTime endTime,
                                                                  int idChannel)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      // where foreigntable.foreignkey = ourprimarykey
      sb.AddConstraint(Operator.Equals, "programName", title);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "startTime", startTime);
      sb.AddConstraint(Operator.GreaterThanOrEquals, "endTime", endTime);
      sb.AddConstraint(Operator.Equals, "idChannel", idChannel);
      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);
      // execute the statement/query and create a collection of User instances from the result set
      return ObjectFactory.GetCollection<Schedule>(stmt.Execute());
    }

    public static Schedule RetrieveSpawnedSchedule(int parentScheduleId, DateTime startTime)
    {
      //select * from 'foreigntable'
      SqlBuilder sb = new SqlBuilder(StatementType.Select, typeof (Schedule));

      sb.AddConstraint(Operator.Equals, "idParentSchedule", parentScheduleId);
      sb.AddConstraint(Operator.Equals, "startTime", startTime);

      // passing true indicates that we'd like a list of elements, i.e. that no primary key
      // constraints from the type being retrieved should be added to the statement
      SqlStatement stmt = sb.GetStatement(true);

      // execute the statement/query and create a collection of User instances from the result set
      IList<Schedule> getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
      if (getList.Count != 0)
      {
        return getList[0];
      }
      else
      {
        //select * from 'foreigntable'
        sb = new SqlBuilder(StatementType.Select, typeof (Schedule));
        sb.AddConstraint(Operator.Equals, "idParentSchedule", parentScheduleId);
        // passing true indicates that we'd like a list of elements, i.e. that no primary key
        // constraints from the type being retrieved should be added to the statement
        stmt = sb.GetStatement(true);

        // execute the statement/query and create a collection of User instances from the result set
        getList = ObjectFactory.GetCollection<Schedule>(stmt.Execute());
        if (getList.Count != 0)
        {
          return getList[0];
        }
      }
      return null;
    }
  }
}