/*
 * Collection class to automate management of 1:n and n:m relations
 * Copyright (C) 2004 Morten Mertner
 * 
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License 2.1 or later, as
 * published by the Free Software Foundation. See the included License.txt
 * or http://www.gnu.org/copyleft/lesser.html for details.
 *
 * $Id: GentleList.cs 1232 2008-03-14 05:36:00Z mm $
 */

using System;
using System.Collections;
using Gentle.Common;

namespace Gentle.Framework
{
	/// <summary>
	/// This is a container class for managed storage of objects. Work in progress.
	/// </summary>
	public class GentleList : ArrayList
	{
		// possible list types that GentleList can manage
		protected enum GentleListType
		{
			StandAlone,
			OneToOne,
			OneToMany,
			ManyToMany
		} ;

		protected PersistenceBroker broker;
		protected GentleListType listType;
		protected IPersistent parent;
		protected ObjectMap parentMap;
		protected ObjectMap containedMap;
		protected Hashtable mappings;
		// the following two keys are used for managing n:m relation objects automatically
		protected ObjectMap viaMap;
		protected GentleRelation viaInstances;

		#region GentleList Initialization Methods
		protected virtual void InitType( Type containedType, IPersistent parent, Type viaType )
		{
			containedMap = ObjectFactory.GetMap( broker, containedType );
			Check.Verify( containedType.GetInterface( "IPersistent", false ) != null,
			              Error.UnsupportedType, containedType );
			listType = parent == null
			           	? GentleListType.StandAlone
			           	:
			           		(viaType == null ? GentleListType.OneToMany : GentleListType.ManyToMany);
		}

		protected virtual void InitParent( IPersistent parent )
		{
			Check.VerifyNotNull( parent, Error.NullParameter, "parent" );
			Check.Verify( parent.IsPersisted || ! parentMap.IsAutoGeneratedPrimaryKey, Error.DeveloperError,
			              "The parent object must have been persisted before you can use the list." );
			this.parent = parent;
			parentMap = ObjectFactory.GetMap( broker, parent );
		}

		protected virtual void InitList( Type viaType, params Type[] relationTypes )
		{
			if( listType == GentleListType.StandAlone )
			{
				broker.RetrieveList( containedMap.Type, this );
			}
			else if( listType == GentleListType.OneToMany )
			{
				// no relation objects for 1:n relationships
				viaInstances = null;
				mappings = containedMap.GetForeignKeyMappings( parentMap, true );
				if( mappings.Count == 0 )
				{
					mappings = viaMap.GetForeignKeyMappings( parentMap, false );
				}
				Check.Verify( mappings.Count > 0, Error.DeveloperError,
				              "The type {0} does not contain a foreign key reference to type {1}.",
				              parentMap.Type, containedMap.Type );
				Check.Verify( mappings.Count == 1, Error.NotImplemented,
				              "GentleList for 1:n relations can not be used with composite keys." );
				// populate self with any existing entries matching the current parent
				Key key = new Key( parentMap.Type, true );
				IDictionaryEnumerator iterator = mappings.GetEnumerator();
				while( iterator.MoveNext() )
				{
					// construct a key to read the data; first obtain the referenced value from
					// the parent object (this is the constraint value used in the select)
					FieldMap fm = iterator.Value as FieldMap;
					object referencedValue = fm.GetValue( parent );
					// if class references self make sure to pick the outgoing column
					if( containedMap.Type == parentMap.Type && ! fm.IsForeignKey )
					{
						fm = iterator.Key as FieldMap;
					}
					key[ fm.MemberName ] = referencedValue;
				}
				broker.RetrieveList( containedMap.Type, key, this );
			}
			else if( listType == GentleListType.ManyToMany )
			{
				// create relation for n:m management
				Type[] relatedTypes = Merge( containedMap.Type, relationTypes );
				viaInstances = new GentleRelation( broker, viaType, parent, relatedTypes );
				// populate the list with any existing entries matching the current relation entries
				ObjectMap viaMap = ObjectFactory.GetMap( broker, viaType );
				SqlBuilder sb = new SqlBuilder( broker, StatementType.Select, containedMap.Type );
				// assume the relation object is the child, i.e. refers to the contained type
				mappings = viaMap.GetForeignKeyMappings( containedMap, true );
				if( mappings.Count == 0 )
				{
					mappings = viaMap.GetForeignKeyMappings( containedMap, false );
				}
				Check.Verify( mappings.Count > 0, Error.DeveloperError,
				              "The type {0} does not contain a foreign key reference to type {1}.",
				              viaMap.Type, containedMap.Type );
				Check.Verify( mappings.Count == 1, Error.NotImplemented,
				              "GentleList for n:m relations can not be used with composite keys." );
				// verify that references point to unique instance
				//Check.Verify( mappings.Count == parentMap.PrimaryKeyCount, Error.DeveloperError,
				//	"The number of fields ({0}) referencing {1} from {2} must equal the primary key count ({3}).",
				//	mappings.Count, parentMap.Type, containedMap.Type, parentMap.PrimaryKeyCount );
				if( viaInstances.Count > 0 )
				{
					foreach( FieldMap remote in mappings.Keys )
					{
						FieldMap local = (FieldMap) mappings[ remote ];
						// viaMap.GetForeignKeyFieldMap( containedMap.Type, local.PropertyName );
						sb.AddConstraint( Operator.In, local.MemberName, viaInstances, remote.MemberName );
					}
					ObjectFactory.GetCollection( containedMap.Type, sb.GetStatement( true ).Execute(), this );
				}
			}
		}
		#endregion

		#region Constructors
		/// <summary>
		/// Use this constructor to create lists of persistent objects that are not related to 
		/// a parent object. This class automatically calls Persist() and Remove() on objects 
		/// when they are added or removed from the list.
		/// </summary>
		/// <param name="containedType">The type of objects to store. The given type must be a 
		/// descendant of the Persistent class or implement the IPersistent interface.</param>
		public GentleList( Type containedType ) : this( null, containedType, null, null )
		{
		}

		/// <summary>
		/// Use this constructor to create lists that represent 1:n relations. The relations between
		/// the contained objects and the parent instance are automatically maintained. This class
		/// automatically calls Persist() and Remove() on objects when they are added or removed
		/// from the list.
		/// </summary>
		/// <param name="parent">The parent of the contained objects. A parent is required for
		/// managing 1:n and n:m relations.</param>
		/// <param name="containedType">The type of objects stored in this list instance. The contained 
		/// type must be supported by Gentle and implement the IPersistent interface.</param>
		public GentleList( Type containedType, IPersistent parent ) :
			this( null, containedType, parent, null )
		{
		}

		/// <summary>
		/// Use this constructor to create lists that represent n:m relations. This class
		/// automatically calls Persist() and Remove() on objects when they are added or removed
		/// from the list. Additionally, the relation objects linking the parent and the contained 
		/// objects are automatically created and destroyed as objects are added or removed from 
		/// the list, thus making the n:m relationship transparent to clients.
		/// </summary>
		/// <param name="containedType">The type of objects stored in this list instance. The contained 
		/// type must be supported by Gentle and implement the IPersistent interface.</param>
		/// <param name="parent">The parent of the contained objects. A parent is required for
		/// managing 1:n and n:m relations.</param>
		/// <param name="viaType">The type of objects used to represent the n:m relationship.</param>
		/// <param name="relationTypes">Additional types from which to extract information when 
		/// creating relations. This is only used in n:m scenarios and permits you to have
		/// relation tables with more than just two columns. The PK is extracted from the
		/// specified types (so you cannot use any member; only PKs can be stored).</param>
		public GentleList( Type containedType, IPersistent parent, Type viaType, params Type[] relationTypes )
			: this( null, containedType, parent, viaType, relationTypes )
		{
		}

		/// <summary>
		/// Use this constructor to create lists of persistent objects that are not related to 
		/// a parent object. This class automatically calls Persist() and Remove() on objects 
		/// when they are added or removed from the list.
		/// </summary>
		/// <param name="broker">The PersistenceBroker to use for connecting to the database.</param>
		/// <param name="containedType">The type of objects to store. The given type must be a 
		/// descendant of the Persistent class or implement the IPersistent interface.</param>
		public GentleList( PersistenceBroker broker, Type containedType ) :
			this( broker, containedType, null, null )
		{
		}

		/// <summary>
		/// Use this constructor to create lists that represent 1:n relations. The relations between
		/// the contained objects and the parent instance are automatically maintained. This class
		/// automatically calls Persist() and Remove() on objects when they are added or removed
		/// from the list.
		/// </summary>
		/// <param name="broker">The PersistenceBroker to use for connecting to the database.</param>
		/// <param name="parent">The parent of the contained objects. A parent is required for
		/// managing 1:n and n:m relations.</param>
		/// <param name="containedType">The type of objects stored in this list instance. The contained 
		/// type must be supported by Gentle and implement the IPersistent interface.</param>
		public GentleList( PersistenceBroker broker, Type containedType, IPersistent parent ) :
			this( broker, containedType, parent, null )
		{
		}

		/// <summary>
		/// Use this constructor to create lists that represent n:m relations. This class
		/// automatically calls Persist() and Remove() on objects when they are added or removed
		/// from the list. Additionally, the relation objects linking the parent and the contained 
		/// objects are automatically created and destroyed as objects are added or removed from 
		/// the list, thus making the n:m relationship transparent to clients.
		/// </summary>
		/// <param name="broker">The PersistenceBroker to use for connecting to the database.</param>
		/// <param name="containedType">The type of objects stored in this list instance. The contained 
		/// type must be supported by Gentle and implement the IPersistent interface.</param>
		/// <param name="parent">The parent of the contained objects. A parent is required for
		/// managing 1:n and n:m relations.</param>
		/// <param name="viaType">The type of objects used to represent the n:m relationship.</param>
		/// <param name="relationTypes">Additional types from which to extract information when 
		/// creating relations. This is only used in n:m scenarios and permits you to have
		/// relation tables with more than just two columns. The PK is extracted from the
		/// specified types (so you cannot use any member; only PKs can be stored).</param>
		public GentleList( PersistenceBroker broker, Type containedType, IPersistent parent,
		                   Type viaType, params Type[] relationTypes )
		{
			this.broker = broker != null ? broker : new PersistenceBroker( containedType );
			InitType( containedType, parent, viaType );
			// trigger additional initialization only for managed relationships
			if( listType == GentleListType.OneToMany || listType == GentleListType.ManyToMany )
			{
				InitParent( parent );
			}
			// populate list with existing data
			InitList( viaType, relationTypes );
		}
		#endregion

		/// <summary>
		/// Search the list of contained objects for an entry whose key matches the given key. The
		/// first match is returned or null if no match was found.
		/// </summary>
		/// <param name="key">The key identifying the object to retrieve.</param>
		/// <returns>The first object matching the key.</returns>
		public virtual object Find( Key key )
		{
			if( Count > 0 )
			{
				foreach( object obj in this )
				{
					Key objKey = Key.GetKey( broker, key.isPropertyKeys, obj );
					if( objKey.Equals( key ) )
					{
						return obj;
					}
				}
			}
			return null;
		}

		protected virtual void UpdateForeignKeyFields( object child )
		{
			if( listType != GentleListType.StandAlone && mappings != null )
			{
				foreach( FieldMap cfm in mappings.Keys )
				{
					FieldMap pfm = mappings[ cfm ] as FieldMap;
					cfm.SetValue( child, pfm.GetValue( parent ) );
				}
			}
		}

		#region Private Helper Methods
		private object[] Merge( object obj, params object[] objs )
		{
			Check.VerifyNotNull( obj, Error.NullParameter, "obj" );
			int size = 1 + (objs != null ? objs.Length : 0);
			object[] result = new object[size];
			result[ 0 ] = obj;
			if( objs != null && objs.Length > 0 )
			{
				objs.CopyTo( result, 1 );
			}
			return result;
		}

		private Type[] Merge( Type obj, params Type[] objs )
		{
			Check.VerifyNotNull( obj, Error.NullParameter, "obj" );
			int size = 1 + (objs != null ? objs.Length : 0);
			Type[] result = new Type[size];
			result[ 0 ] = obj;
			if( objs != null && objs.Length > 0 )
			{
				objs.CopyTo( result, 1 );
			}
			return result;
		}
		#endregion

		#region Add
		/// <summary>
		/// Add an object to the list. For 1:n relations, any references on the object being added
		/// to the parent of the list will be updated to match the parents current values, and the 
		/// object will be inserted if it is a new one. For n:m relations, a new relation object is
		/// created and inserted (the object itself is never persisted).
		/// </summary>
		/// <param name="value">The object to add to the list</param>
		/// <returns>The index of the newly added object</returns>
		public override int Add( object value )
		{
			return Add( null, value, null );
		}

		/// <summary>
		/// Add an object to the list. For 1:n relations, any references on the object being added
		/// to the parent of the list will be updated to match the parents current values, and the 
		/// object will be inserted if it is a new one. For n:m relations, a new relation object is
		/// created and inserted (the object itself is never persisted).
		/// </summary>
		/// <param name="value">The object to add to the list</param>
		/// <param name="relatedObjects">A list of values to use when creating the n:m relation 
		/// object.</param>
		/// <returns>The index of the newly added object</returns>
		public virtual int Add( object value, params object[] relatedObjects )
		{
			return Add( null, value, relatedObjects );
		}

		/// <summary>
		/// Add an object to the list. For 1:n relations, any references on the object being added
		/// to the parent of the list will be updated to match the parents current values, and the 
		/// object will be inserted if it is a new one. For n:m relations, a new relation object is
		/// created and inserted (the object itself is never persisted).
		/// </summary>
		/// <param name="transaction">The transaction within which to execute statements.</param>
		/// <param name="value">The object to add to the list</param>
		/// <param name="relatedObjects">A list of values to use when creating the n:m relation 
		/// object.</param>
		/// <returns>The index of the newly added object</returns>
		public virtual int Add( Transaction transaction, object value, params object[] relatedObjects )
		{
			Check.VerifyNotNull( value, Error.NullParameter, "value" );
			Check.Verify( containedMap.Type.Equals( value.GetType() ) ||
			              value.GetType().IsSubclassOf( containedMap.Type ),
			              Error.UnsupportedType, value.GetType() );
			// skip adding objects matching existing data
			object val = Find( Key.GetKey( broker, true, value ) );
			value = val ?? value;
			// manage 1:n relation
			if( viaInstances == null )
			{
				Check.Verify( relatedObjects == null || relatedObjects.Length == 0,
				              Error.NotImplemented, "Request incompatible with GentleList in OneToMany mode." );
				// manage added object
				IPersistent obj = value as IPersistent;
				if( ! obj.IsPersisted )
				{
					// first we update the foreign key property on the added object
					UpdateForeignKeyFields( value );
					if( transaction != null )
					{
						transaction.Persist( obj );
					}
					else
					{
						obj.Persist();
					}
				}
			}
			else
			{
				// manage n:m relation object - creates new relation object using parent and value
				object[] args = Merge( value, relatedObjects );
				viaInstances.Add( transaction, args );
			}
			// this bit ensures object uniqing by disallowing objects with identical PK 
			// from being in the list more than once
			if( val == null )
			{
				return base.Add( value );
			}
			else
			{
				return IndexOf( val );
			}
		}

		/// <summary>
		/// Add a list of objects to the list.
		/// </summary>
		/// <param name="collection">The collection of objects to add to the list.</param>
		public override void AddRange( ICollection collection )
		{
			foreach( object obj in collection )
			{
				Add( obj );
			}
		}
		#endregion

		#region Remove
		/// <summary>
		/// Remove an object from the list. For 1:n relations, if the object is persisted it will also
		/// be removed from the database. For n:m relations, the relation object is removed (the object 
		/// being removed is left untouched and must manually be removed if so desired).
		/// </summary>
		/// <param name="value">The object to remove from the list</param>
		public override void Remove( object value )
		{
			Remove( null, value );
		}

		/// <summary>
		/// Remove an object from the list. For 1:n relations, if the object is persisted it will also
		/// be removed from the database. For n:m relations, the relation object is removed (the object 
		/// being removed is left untouched and must manually be removed if so desired).
		/// </summary>
		/// <param name="transaction">The transaction within which to execute statements.</param>
		/// <param name="value">The object to remove from the list</param>
		public virtual void Remove( Transaction transaction, object value )
		{
			object val = Find( Key.GetKey( broker, false, value ) );
			value = val ?? value;
			if( Contains( value ) )
			{
				Check.VerifyNotNull( value, Error.NullParameter, "value" );
				Check.Verify( containedMap.Type.Equals( value.GetType() ) ||
				              value.GetType().IsSubclassOf( containedMap.Type ),
				              Error.UnsupportedType, value.GetType() );
				// call remove even if contains was false to make sure error reporting is unchanged
				// Note: calling ArrayList/base class RemoveAt seems to work but calling Remove does
				// not - calling base.Remove ends up here again - must be a bug in net-1.1.
				base.RemoveAt( IndexOf( value ) );
				if( viaInstances == null )
				{
					// manage removed object
					IPersistent obj = value as IPersistent;
					if( obj.IsPersisted )
					{
						if( transaction != null )
						{
							transaction.Remove( obj );
						}
						else
						{
							obj.Remove();
						}
					}
				}
				else
				{
					// manage n:m relation object
					viaInstances.Remove( transaction, value );
				}
			}
		}

		/// <summary>
		/// Remove an object from the list. For 1:n relations, if the object is persisted it will also
		/// be removed from the database. For n:m relations, the relation object is removed (the object 
		/// being removed is left untouched and must manually be removed if so desired).
		/// </summary>
		/// <param name="index">The index of the object to remove from the list</param>
		public override void RemoveAt( int index )
		{
			Check.Verify( index >= 0 && index < Count, Error.NullParameter, "index" );
			Remove( this[ index ] );
		}
		#endregion

		#region Persist All
		/// <summary>
		/// Recursively persist all objects in list. This method will do nothing for n:m relations.
		/// </summary>
		public virtual void Persist()
		{
			Persist( null );
		}

		/// <summary>
		/// Recursively persist all objects in list. This method will do nothing for n:m relations.
		/// </summary>
		/// <param name="transaction">The transaction within which to execute statements.</param>
		public virtual void Persist( Transaction transaction )
		{
			if( viaMap == null )
			{
				foreach( IPersistent obj in this )
				{
					if( transaction != null )
					{
						transaction.Persist( obj );
					}
					else
					{
						obj.Persist();
					}
				}
			}
		}
		#endregion

		#region Methods for accessing the relational objects of a GentleList in ManyToMany mode
		public object Via( int index )
		{
			if( listType != GentleListType.ManyToMany )
			{
				return null;
			}
			Key key = new Key( viaMap.Type, true );
			key = Key.GetKey( broker, key, true, parent );
			key = Key.GetKey( broker, key, true, this[ index ] );
			return broker.RetrieveInstance( viaMap.Type, key );
		}

		public object Via( object obj )
		{
			if( listType != GentleListType.ManyToMany )
			{
				return null;
			}
			if( ! Contains( obj ) )
			{
				return null;
			}
			Key key = new Key( viaMap.Type, true );
			key = Key.GetKey( broker, key, true, parent );
			int index = IndexOf( obj );
			key = Key.GetKey( broker, key, true, this[ index ] );
			return broker.RetrieveInstance( viaMap.Type, key );
		}
		#endregion
	}
}