/*
 * MySQL database schema analyzer
 * Copyright (C) 2004 Morten Mertner
 * 
 * This library is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License 2.1 or later, as
 * published by the Free Software Foundation. See the included License.txt
 * or http://www.gnu.org/copyleft/lesser.html for details.
 *
 * $Id: MySQLAnalyzer.cs 1232 2008-03-14 05:36:00Z mm $
 */

using System;
using System.Text.RegularExpressions;
using Gentle.Common;
using Gentle.Framework;
using MySql.Data.MySqlClient;

namespace Gentle.Provider.MySQL
{
	public class MySQLAnalyzer : GentleAnalyzer
	{
		// http://www.mysql.com/documentation/mysql/bychapter/manual_SQL_Syntax.html#SHOW 
		private const string selectTables = "show tables";
		// returns columns: Field, Type, Null, Key, Default, Extra
		private const string selectColumns = "show columns from `{0}`"; // table name (unquoted)
		// returns columns: Name, Type, Row_format, Rows, Avg_row_length, Data_length, Max_data_length,
		//   Index_length, Data_free, Auto_increment, Create_time, Update_time, Check_time, Create_options,
		//   Comment (as "InnoDB free: 3072 kB; (ListId) REFER test/List(ListId)"		 
		private const string selectConstraints = "show create table `{0}`";

		public MySQLAnalyzer( IGentleProvider provider ) : base( provider )
		{
		}

		public override ColumnInformation AnalyzerCapability
		{
			// ciBasic = ColumnInformation.Size | ColumnInformation.Type;
			// ciExtra = ColumnInformation.IsNullable | ColumnInformation.IsUnique;
			// ciKey = ColumnInformation.IsPrimaryKey | ColumnInformation.IsAutoGenerated;
			// ciRelationOut = ColumnInformation.IsForeignKey;
			// ciRelationIn = ColumnInformation.HasForeignKey;
			// ciLocal = ciBasic | ciExtra | ciKey | ciRelationOut;
			// ciAll = ciLocal | ciRelationIn;
			get { return ColumnInformation.ciLocal; }
		}

		public override void Analyze( string tableName )
		{
			try
			{
				bool isSingleRun = tableName != null;
				SqlStatement stmt = broker.GetStatement( selectTables );
				stmt.StatementType = StatementType.Select;
				SqlResult sr = stmt.Execute();
				for( int i = 0; i < sr.Rows.Count; i++ )
				{
					try
					{
						string dbTableName = sr.GetString( i, 0 );
						if( ! isSingleRun || tableName.ToLower().Equals( dbTableName.ToLower() ) )
						{
							TableMap map = GetTableMap( dbTableName );
							if( map == null )
							{
								map = new TableMap( provider, dbTableName );
								maps[ dbTableName.ToLower() ] = map;
							}
							// get column information for this table
							GetColumnData( map );
							// get foreign key information
							GetConstraintData( map );
							// abort loop if analyzing single table only
							if( isSingleRun )
							{
								break;
							}
						}
					}
					catch( GentleException fe )
					{
						// ignore errors caused by tables found in db but for which no map exists
						// TODO this should be a config option
						if( fe.Error != Error.NoObjectMapForTable )
						{
							throw fe;
						}
					}
				}
			}
			catch( Exception e )
			{
				Check.Fail( e, Error.Unspecified, "An error occurred while analyzing the database schema." );
			}
		}

		private void GetColumnData( TableMap map )
		{
			string sql = String.Format( selectColumns, map.TableName );
			SqlStatement stmt = broker.GetStatement( sql );
			stmt.StatementType = StatementType.Select;
			SqlResult sr = stmt.Execute();
			for( int i = 0; i < sr.Rows.Count; i++ )
			{
				// returns columns: Field, Type, Null, Key, Default, Extra
				string columnName = sr.GetString( i, "Field" );
				FieldMap fm = map.GetFieldMapFromColumn( columnName );
				if( fm == null )
				{
					fm = new FieldMap( map, columnName );
					map.Fields.Add( fm );
				}
				if( fm != null )
				{
					string typeinfo = sr.GetString( i, "Type" );
					bool isUnsigned;
					fm.SetDbType( ExtractType( typeinfo, out isUnsigned ), isUnsigned );
					if( fm.DbType == (long) MySqlDbType.Enum )
					{
						fm.HandleEnumAsString = true;
					}
					fm.SetSize( ExtractSize( typeinfo ) );
					fm.SetIsNullable( sr.GetString( i, "Null" ).Equals( "YES" ) );
					fm.SetIsPrimaryKey( sr.GetString( i, "Key" ).Equals( "PRI" ) );
					if( fm.IsPrimaryKey )
					{
						fm.SetIsAutoGenerated( sr.GetString( i, "Extra" ).Equals( "auto_increment" ) );
					}
				}
				else // raise an error if we've detected a database/type mismatch
				{
					bool hasDefault = sr.GetObject( i, "Default" ) != null;
					// TODO disabled due to code restructuring 
					// Check.Verify( isNullable || hasDefault, Error.NoPropertyForNotNullColumn, column, map.Type );
				}
			}
		}

		private void GetConstraintData( TableMap map )
		{
			SqlStatement stmt = broker.GetStatement( String.Format( selectConstraints, map.TableName ) );
			stmt.StatementType = StatementType.Select;
			SqlResult sr = stmt.Execute();
			if( sr.Rows.Count == 1 )
			{
				// returns columns: Name, Type, Row_format, Rows, Avg_row_length, Data_length, Max_data_length,
				//   Index_length, Data_free, Auto_increment, Create_time, Update_time, Check_time, Create_options,
				//   Comment (as "InnoDB free: 3072 kB; (ListId) REFER test/List(ListId)"		 
				string comment = sr.GetString( 0, 1 ); // column 1 is either "Create table" or "Create view" 
				if( comment != null && comment.Length > 5 )
				{
					string[] comments = comment.Split( ',' );
					foreach( string cmt in comments )
					{
						string tmp = cmt.Trim();
						// samples:
						// "(Column) REFER database/Table(Column)"
						// "(`Column`) REFER `database/Table`(`Column`)"
						string pattern = @"\(`?(?<column>\w+)`?\) REFER .*/(?<fkTable>\w+)[`\s]+\(`?(?<fkColumn>\w+)`?\)";
						Regex regex = new Regex( pattern, RegexOptions.ExplicitCapture | RegexOptions.Compiled );
						Match m = regex.Match( tmp );
						if( m.Success )
						{
							FieldMap fm = map.GetFieldMapFromColumn( m.Groups[ "column" ].Value );
							if( fm != null )
							{
								fm.SetForeignKeyTableName( m.Groups[ "fkTable" ].Value );
								fm.SetForeignKeyColumnName( m.Groups[ "fkColumn" ].Value );
							}
						}
						else
						{
							//CONSTRAINT `fk_employee_type_employee` FOREIGN KEY (`employee_type_id`) REFERENCES `employee_type` (`employee_type_id`) ON DELETE CASCADE ON UPDATE CASCADE
							pattern = @"[\s\w]FOREIGN KEY\s\(`?(?<column>\w+)`?\) REFERENCES `?(?<fkTable>\w+)`? \(`?(?<fkColumn>\w+)`?\)[\s\w]+";
							Regex regexNew = new Regex( pattern, RegexOptions.ExplicitCapture | RegexOptions.Compiled );
							Match mNew = regexNew.Match( tmp );
							if( mNew.Success )
							{
								// string constraintPart = mNew.Groups["constraint"].Value;
								FieldMap fm = map.GetFieldMapFromColumn( mNew.Groups[ "column" ].Value );
								if( fm != null )
								{
									fm.SetForeignKeyTableName( mNew.Groups[ "fkTable" ].Value );
									fm.SetForeignKeyColumnName( mNew.Groups[ "fkColumn" ].Value );
								}
							}
							else if( tmp != null )
							{
								int index = tmp.IndexOf( "REFER" );
								if( index > 0 )
								{
									string columnName = ExtractColumn( tmp.Substring( 0, index - 1 ) );
									tmp = tmp.Substring( index + 5, tmp.Length - index - 5 ).Trim();
									index = tmp.IndexOf( "/" );
									int start = tmp.IndexOf( "(" );
									int end = tmp.IndexOf( ")" );
									if( index > 0 && start > 0 && end > start )
									{
										string foreignTable = tmp.Substring( index + 1, start - index - 1 );
										string foreignColumn = tmp.Substring( start + 1, end - start - 1 );
										FieldMap fm = map.GetFieldMapFromColumn( columnName );
										fm.SetForeignKeyTableName( foreignTable );
										fm.SetForeignKeyColumnName( foreignColumn );
									}
								}
							}
						}
					}
				}
			}
		}

		private static string ExtractColumn( string columnInfo )
		{
			string tmp = columnInfo.Trim();
			if( tmp.StartsWith( "(" ) )
			{
				tmp = tmp.Substring( 1, tmp.Length - 1 );
			}
			if( tmp.EndsWith( ")" ) )
			{
				tmp = tmp.Substring( 0, tmp.Length - 1 );
			}
			return tmp;
		}

		private static string ExtractType( string typeInfo, out bool isUnsigned )
		{
			// determine if field is unsigned (text "unsigned" after size)
			int sp = typeInfo.IndexOf( " " );
			isUnsigned = sp > 0 && typeInfo.IndexOf( "unsigned", sp, typeInfo.Length - sp ) > 0;
			// get type text
			int pos = typeInfo.IndexOf( "(" );
			if( pos != -1 )
			{
				return typeInfo.Substring( 0, pos );
			}
			else // return type string without "unsigned" even if there was no size field
			{
				return isUnsigned ? typeInfo.Substring( 0, sp ) : typeInfo;
			}
		}

		private static int ExtractSize( string typeInfo )
		{
			int pos = typeInfo.IndexOf( "(" );
			if( pos != -1 )
			{
				// get field size as value inside parentheses
				int pos2 = typeInfo.IndexOf( ")" );
				string size = typeInfo.Substring( pos + 1, pos2 - pos - 1 );
				// check that inner parenthesis is not a string (type is likely an enum)
				if( size.IndexOfAny( new[] { '\'', '"' } ) != -1 )
				{
					return 0;
				}
				// only get first field (in case size is something like 10,3)
				pos = size.IndexOf( "," );
				if( pos != -1 )
				{
					return Convert.ToInt32( size.Substring( 0, pos ) );
				}
				else
				{
					return Convert.ToInt32( size );
				}
			}
			else
			{
				return 0;
			}
		}
	}
}